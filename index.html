<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>–ó–º–µ–π–∫–∞ —Å –±–æ—Ç–∞–º–∏</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            min-height: 100dvh;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }
        
        #gameCanvas {
            border: 3px solid #4ade80;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(74, 222, 128, 0.3);
            max-width: 100%;
            display: block;
        }
        
        .glow-green {
            text-shadow: 0 0 10px #4ade80, 0 0 20px #4ade80;
        }
        
        .control-btn {
            width: 60px;
            height: 60px;
            background: rgba(74, 222, 128, 0.3);
            border: 2px solid #4ade80;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            transition: all 0.1s;
            -webkit-tap-highlight-color: transparent;
        }
        
        .control-btn:active {
            background: rgba(74, 222, 128, 0.6);
            transform: scale(0.95);
        }
        
        .control-btn:disabled {
            opacity: 0.5;
        }
        
        @media (min-width: 768px) {
            .control-btn {
                width: 70px;
                height: 70px;
                font-size: 28px;
            }
        }
        
        .snake-info {
            transition: all 0.3s ease;
        }
        
        .stats-panel {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        
        .stats-panel.open {
            max-height: 300px;
        }
        
        /* Prevent pull-to-refresh */
        body {
            overscroll-behavior: none;
        }
        
        /* Landscape adjustments */
        @media (orientation: landscape) and (max-height: 500px) {
            .control-btn {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
        }
    </style>
</head>
<body class="text-white p-2 sm:p-4">
    <div class="max-w-4xl mx-auto flex flex-col h-screen h-[100dvh]">
        <!-- Header -->
        <div class="flex-shrink-0 text-center mb-2">
            <h1 class="text-xl sm:text-2xl md:text-3xl font-bold glow-green text-green-400">üêç –ó–º–µ–π–∫–∞ —Å –ë–æ—Ç–∞–º–∏ üêç</h1>
            <p class="text-xs sm:text-sm text-gray-400 hidden sm:block">–°–≤–∞–π–ø–∞–π—Ç–µ –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏</p>
        </div>
        
        <!-- Main Game Area -->
        <div class="flex-1 flex flex-col min-h-0">
            <!-- Canvas Container -->
            <div class="flex-1 flex items-center justify-center min-h-0 mb-2">
                <canvas id="gameCanvas"></canvas>
            </div>
            
            <!-- Bottom Controls & Stats -->
            <div class="flex-shrink-0">
                <!-- Quick Stats Bar -->
                <div class="flex justify-between items-center bg-gray-800/80 rounded-lg px-3 py-2 mb-2 text-sm">
                    <div class="flex items-center gap-3">
                        <span>üçé <span id="appleCount">0</span></span>
                        <span>üêç <span id="snakeCount">0</span></span>
                        <span>üíÄ <span id="killCount">0</span></span>
                    </div>
                    <div class="flex items-center gap-2">
                        <span class="text-green-400 font-bold">–í—ã: <span id="playerScore">0</span></span>
                        <button id="statsToggle" class="text-lg" onclick="toggleStats()">üìä</button>
                    </div>
                </div>
                
                <!-- Collapsible Scoreboard -->
                <div id="statsPanel" class="stats-panel bg-gray-800/80 rounded-lg mb-2">
                    <div class="p-3">
                        <h2 class="text-sm font-bold mb-2 text-center border-b border-gray-600 pb-1">üèÜ –¢–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤</h2>
                        <div id="scoreboard" class="space-y-1 max-h-32 overflow-y-auto text-sm">
                        </div>
                    </div>
                </div>
                
                <!-- Touch Controls -->
                <div class="flex justify-center items-center gap-2 pb-2">
                    <!-- Left side - Restart -->
                    <button onclick="restartGame()" class="control-btn !w-12 !h-12 sm:!w-14 sm:!h-14 !text-lg">
                        üîÑ
                    </button>
                    
                    <!-- D-Pad -->
                    <div class="grid grid-cols-3 gap-1">
                        <div></div>
                        <button id="btnUp" class="control-btn" ontouchstart="handleControl('UP', event)" onmousedown="handleControl('UP', event)">
                            ‚ñ≤
                        </button>
                        <div></div>
                        
                        <button id="btnLeft" class="control-btn" ontouchstart="handleControl('LEFT', event)" onmousedown="handleControl('LEFT', event)">
                            ‚óÄ
                        </button>
                        <div class="w-[60px] h-[60px] sm:w-[70px] sm:h-[70px]"></div>
                        <button id="btnRight" class="control-btn" ontouchstart="handleControl('RIGHT', event)" onmousedown="handleControl('RIGHT', event)">
                            ‚ñ∂
                        </button>
                        
                        <div></div>
                        <button id="btnDown" class="control-btn" ontouchstart="handleControl('DOWN', event)" onmousedown="handleControl('DOWN', event)">
                            ‚ñº
                        </button>
                        <div></div>
                    </div>
                    
                    <!-- Right side - Pause -->
                    <button onclick="togglePause()" id="pauseBtn" class="control-btn !w-12 !h-12 sm:!w-14 sm:!h-14 !text-lg">
                        ‚è∏Ô∏è
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Game Over Modal -->
        <div id="gameOverModal" class="fixed inset-0 bg-black/80 flex items-center justify-center hidden z-50 p-4">
            <div class="bg-gray-800 rounded-2xl p-6 sm:p-8 text-center max-w-sm w-full mx-4">
                <h2 class="text-2xl sm:text-3xl font-bold text-red-500 mb-4">üíÄ –ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!</h2>
                <p class="text-lg sm:text-xl mb-2">–í–∞—à —Å—á—ë—Ç: <span id="finalScore" class="text-green-400 font-bold">0</span></p>
                <p class="text-gray-400 mb-6 text-sm sm:text-base" id="deathReason">–í–∞—Å —Å—ä–µ–ª–∞ –∑–º–µ–π–∫–∞!</p>
                <button onclick="restartGame()" class="bg-green-600 hover:bg-green-500 active:bg-green-700 text-white font-bold py-3 px-8 rounded-lg text-lg transition w-full">
                    –ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞
                </button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Responsive canvas sizing
        function resizeCanvas() {
            const container = canvas.parentElement;
            const maxWidth = container.clientWidth;
            const maxHeight = container.clientHeight;
            
            // Calculate optimal cell size based on screen
            const isPortrait = window.innerHeight > window.innerWidth;
            const targetCells = isPortrait ? 30 : 45;
            
            let cellSize = Math.floor(maxWidth / targetCells);
            cellSize = Math.max(10, Math.min(cellSize, 16));
            
            const gridWidth = Math.floor(maxWidth / cellSize);
            const gridHeight = Math.floor(maxHeight / cellSize);
            
            canvas.width = gridWidth * cellSize;
            canvas.height = gridHeight * cellSize;
            
            return { cellSize, gridWidth, gridHeight };
        }
        
        let { cellSize: CELL_SIZE, gridWidth: GRID_WIDTH, gridHeight: GRID_HEIGHT } = resizeCanvas();
        
        const BOT_COUNT = window.innerWidth < 600 ? 4 : 6;
        const APPLE_COUNT = Math.floor((GRID_WIDTH * GRID_HEIGHT) / 100);
        const HUNT_SIZE_ADVANTAGE = 3;
        
        let snakes = [];
        let apples = [];
        let totalKills = 0;
        let gameRunning = true;
        let gamePaused = false;
        let playerSnake = null;
        
        const DIRECTIONS = {
            UP: { x: 0, y: -1 },
            DOWN: { x: 0, y: 1 },
            LEFT: { x: -1, y: 0 },
            RIGHT: { x: 1, y: 0 }
        };
        
        const BOT_COLORS = [
            { head: '#ef4444', body: '#dc2626', name: '–ö—Ä–∞—Å–Ω—ã–π' },
            { head: '#3b82f6', body: '#2563eb', name: '–°–∏–Ω–∏–π' },
            { head: '#f59e0b', body: '#d97706', name: '–ó–æ–ª–æ—Ç–æ–π' },
            { head: '#8b5cf6', body: '#7c3aed', name: '–§–∏–æ–ª–µ—Ç' },
            { head: '#ec4899', body: '#db2777', name: '–†–æ–∑–æ–≤—ã–π' },
            { head: '#06b6d4', body: '#0891b2', name: '–ë–∏—Ä—é–∑–∞' },
            { head: '#f97316', body: '#ea580c', name: '–û—Ä–∞–Ω–∂' },
            { head: '#84cc16', body: '#65a30d', name: '–õ–∞–π–º' }
        ];
        
        class Snake {
            constructor(x, y, isPlayer = false, colorScheme = null) {
                this.body = [{ x, y }];
                this.direction = Object.values(DIRECTIONS)[Math.floor(Math.random() * 4)];
                this.nextDirection = this.direction;
                this.isPlayer = isPlayer;
                this.alive = true;
                this.score = 0;
                this.huntTarget = null;
                this.huntTimer = 0;
                
                if (isPlayer) {
                    this.colors = { head: '#4ade80', body: '#22c55e', name: '–í—ã' };
                } else {
                    this.colors = colorScheme || BOT_COLORS[Math.floor(Math.random() * BOT_COLORS.length)];
                }
                
                for (let i = 0; i < 2; i++) {
                    this.body.push({ 
                        x: x - this.direction.x * (i + 1), 
                        y: y - this.direction.y * (i + 1) 
                    });
                }
            }
            
            get head() { return this.body[0]; }
            get length() { return this.body.length; }
            
            move() {
                if (!this.alive) return;
                
                this.direction = this.nextDirection;
                
                const newHead = {
                    x: this.head.x + this.direction.x,
                    y: this.head.y + this.direction.y
                };
                
                if (newHead.x < 0) newHead.x = GRID_WIDTH - 1;
                if (newHead.x >= GRID_WIDTH) newHead.x = 0;
                if (newHead.y < 0) newHead.y = GRID_HEIGHT - 1;
                if (newHead.y >= GRID_HEIGHT) newHead.y = 0;
                
                this.body.unshift(newHead);
                this.body.pop();
            }
            
            grow(amount = 1) {
                for (let i = 0; i < amount; i++) {
                    const tail = this.body[this.body.length - 1];
                    this.body.push({ ...tail });
                }
                this.score += amount;
            }
            
            setDirection(dir) {
                if (dir.x !== -this.direction.x || dir.y !== -this.direction.y) {
                    this.nextDirection = dir;
                }
            }
            
            checkCollision(x, y, excludeHead = false) {
                const start = excludeHead ? 1 : 0;
                for (let i = start; i < this.body.length; i++) {
                    if (this.body[i].x === x && this.body[i].y === y) {
                        return true;
                    }
                }
                return false;
            }
            
            botAI() {
                if (this.isPlayer || !this.alive) return;
                
                const possibleDirs = Object.values(DIRECTIONS).filter(dir => {
                    if (dir.x === -this.direction.x && dir.y === -this.direction.y) return false;
                    
                    const nextX = (this.head.x + dir.x + GRID_WIDTH) % GRID_WIDTH;
                    const nextY = (this.head.y + dir.y + GRID_HEIGHT) % GRID_HEIGHT;
                    
                    if (this.checkCollision(nextX, nextY)) return false;
                    
                    for (const snake of snakes) {
                        if (snake !== this && snake.alive && snake.checkCollision(nextX, nextY)) {
                            return false;
                        }
                    }
                    
                    return true;
                });
                
                if (possibleDirs.length === 0) return;
                
                this.huntTimer--;
                if (this.huntTimer <= 0) {
                    this.huntTarget = null;
                    
                    if (Math.random() < 0.3) {
                        const prey = snakes.filter(s => 
                            s !== this && 
                            s.alive && 
                            this.length >= s.length + HUNT_SIZE_ADVANTAGE
                        );
                        
                        if (prey.length > 0) {
                            this.huntTarget = prey[Math.floor(Math.random() * prey.length)];
                            this.huntTimer = 50 + Math.floor(Math.random() * 100);
                        }
                    }
                }
                
                let target = null;
                
                if (this.huntTarget && this.huntTarget.alive) {
                    target = this.huntTarget.head;
                } else {
                    let nearestApple = null;
                    let nearestDist = Infinity;
                    
                    for (const apple of apples) {
                        const dist = Math.abs(apple.x - this.head.x) + Math.abs(apple.y - this.head.y);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestApple = apple;
                        }
                    }
                    
                    if (nearestApple) {
                        target = nearestApple;
                    }
                }
                
                if (target) {
                    const bestDir = possibleDirs.reduce((best, dir) => {
                        const nextX = (this.head.x + dir.x + GRID_WIDTH) % GRID_WIDTH;
                        const nextY = (this.head.y + dir.y + GRID_HEIGHT) % GRID_HEIGHT;
                        
                        const dist = Math.abs(target.x - nextX) + Math.abs(target.y - nextY);
                        const bestNextX = (this.head.x + best.x + GRID_WIDTH) % GRID_WIDTH;
                        const bestNextY = (this.head.y + best.y + GRID_HEIGHT) % GRID_HEIGHT;
                        const bestDist = Math.abs(target.x - bestNextX) + Math.abs(target.y - bestNextY);
                        
                        return dist < bestDist ? dir : best;
                    }, possibleDirs[0]);
                    
                    if (Math.random() < 0.1) {
                        this.nextDirection = possibleDirs[Math.floor(Math.random() * possibleDirs.length)];
                    } else {
                        this.nextDirection = bestDir;
                    }
                } else {
                    this.nextDirection = possibleDirs[Math.floor(Math.random() * possibleDirs.length)];
                }
            }
            
            draw() {
                if (!this.alive) return;
                
                for (let i = this.body.length - 1; i >= 0; i--) {
                    const segment = this.body[i];
                    const isHead = i === 0;
                    
                    ctx.fillStyle = isHead ? this.colors.head : this.colors.body;
                    
                    const x = segment.x * CELL_SIZE;
                    const y = segment.y * CELL_SIZE;
                    const size = CELL_SIZE - 1;
                    
                    if (isHead) {
                        ctx.beginPath();
                        ctx.roundRect(x, y, size, size, 3);
                        ctx.fill();
                        
                        ctx.fillStyle = 'white';
                        const eyeSize = Math.max(2, CELL_SIZE / 5);
                        const eyeOffset = Math.max(2, CELL_SIZE / 5);
                        
                        if (this.direction.x === 1) {
                            ctx.fillRect(x + size - eyeOffset - eyeSize, y + 2, eyeSize, eyeSize);
                            ctx.fillRect(x + size - eyeOffset - eyeSize, y + size - 2 - eyeSize, eyeSize, eyeSize);
                        } else if (this.direction.x === -1) {
                            ctx.fillRect(x + eyeOffset, y + 2, eyeSize, eyeSize);
                            ctx.fillRect(x + eyeOffset, y + size - 2 - eyeSize, eyeSize, eyeSize);
                        } else if (this.direction.y === -1) {
                            ctx.fillRect(x + 2, y + eyeOffset, eyeSize, eyeSize);
                            ctx.fillRect(x + size - 2 - eyeSize, y + eyeOffset, eyeSize, eyeSize);
                        } else {
                            ctx.fillRect(x + 2, y + size - eyeOffset - eyeSize, eyeSize, eyeSize);
                            ctx.fillRect(x + size - 2 - eyeSize, y + size - eyeOffset - eyeSize, eyeSize, eyeSize);
                        }
                        
                        if (this.huntTarget && this.huntTarget.alive) {
                            ctx.strokeStyle = '#ff0000';
                            ctx.lineWidth = 2;
                            ctx.strokeRect(x - 1, y - 1, size + 2, size + 2);
                        }
                    } else {
                        ctx.beginPath();
                        ctx.roundRect(x, y, size, size, 2);
                        ctx.fill();
                    }
                }
            }
        }
        
        function spawnApple() {
            let x, y, valid;
            let attempts = 0;
            
            do {
                x = Math.floor(Math.random() * GRID_WIDTH);
                y = Math.floor(Math.random() * GRID_HEIGHT);
                valid = true;
                
                for (const snake of snakes) {
                    if (snake.alive && snake.checkCollision(x, y)) {
                        valid = false;
                        break;
                    }
                }
                
                for (const apple of apples) {
                    if (apple.x === x && apple.y === y) {
                        valid = false;
                        break;
                    }
                }
                
                attempts++;
            } while (!valid && attempts < 100);
            
            if (valid) {
                apples.push({ x, y, pulse: Math.random() * Math.PI * 2 });
            }
        }
        
        function spawnSnake(isPlayer = false, colorScheme = null) {
            let x, y, valid;
            let attempts = 0;
            
            do {
                x = Math.floor(Math.random() * (GRID_WIDTH - 10)) + 5;
                y = Math.floor(Math.random() * (GRID_HEIGHT - 10)) + 5;
                valid = true;
                
                for (const snake of snakes) {
                    const dist = Math.abs(snake.head.x - x) + Math.abs(snake.head.y - y);
                    if (dist < 8) {
                        valid = false;
                        break;
                    }
                }
                
                attempts++;
            } while (!valid && attempts < 50);
            
            return new Snake(x, y, isPlayer, colorScheme);
        }
        
        function initGame() {
            // Recalculate canvas size
            const sizes = resizeCanvas();
            CELL_SIZE = sizes.cellSize;
            GRID_WIDTH = sizes.gridWidth;
            GRID_HEIGHT = sizes.gridHeight;
            
            snakes = [];
            apples = [];
            totalKills = 0;
            gameRunning = true;
            gamePaused = false;
            
            playerSnake = spawnSnake(true);
            snakes.push(playerSnake);
            
            const botCount = window.innerWidth < 600 ? 4 : 6;
            for (let i = 0; i < botCount; i++) {
                snakes.push(spawnSnake(false, BOT_COLORS[i % BOT_COLORS.length]));
            }
            
            const appleCount = Math.max(8, Math.floor((GRID_WIDTH * GRID_HEIGHT) / 80));
            for (let i = 0; i < appleCount; i++) {
                spawnApple();
            }
            
            document.getElementById('gameOverModal').classList.add('hidden');
            document.getElementById('pauseBtn').textContent = '‚è∏Ô∏è';
        }
        
        function checkCollisions() {
            for (const snake of snakes) {
                if (!snake.alive) continue;
                
                for (let i = apples.length - 1; i >= 0; i--) {
                    if (snake.head.x === apples[i].x && snake.head.y === apples[i].y) {
                        snake.grow();
                        apples.splice(i, 1);
                        spawnApple();
                    }
                }
                
                if (snake.checkCollision(snake.head.x, snake.head.y, true)) {
                    killSnake(snake, null, '–í—Ä–µ–∑–∞–ª–∏—Å—å –≤ —Å–µ–±—è');
                    continue;
                }
                
                for (const other of snakes) {
                    if (other === snake || !other.alive) continue;
                    
                    if (snake.head.x === other.head.x && snake.head.y === other.head.y) {
                        if (snake.length > other.length) {
                            killSnake(other, snake, `–°—ä–µ–¥–µ–Ω ${snake.colors.name}`);
                        } else if (other.length > snake.length) {
                            killSnake(snake, other, `–°—ä–µ–¥–µ–Ω ${other.colors.name}`);
                        } else {
                            killSnake(snake, null, '–õ–æ–±–æ–≤–æ–µ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ');
                            killSnake(other, null, '–õ–æ–±–æ–≤–æ–µ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ');
                        }
                        continue;
                    }
                    
                    if (other.checkCollision(snake.head.x, snake.head.y)) {
                        killSnake(snake, other, `–°—ä–µ–¥–µ–Ω ${other.colors.name}`);
                    }
                }
            }
        }
        
        function killSnake(victim, killer, reason) {
            if (!victim.alive) return;
            
            victim.alive = false;
            totalKills++;
            
            if (killer) {
                const bonusScore = Math.floor(victim.score * 0.5) + victim.length;
                killer.grow(bonusScore);
            }
            
            if (!victim.isPlayer) {
                setTimeout(() => {
                    const newSnake = spawnSnake(false, victim.colors);
                    const index = snakes.indexOf(victim);
                    if (index !== -1) {
                        snakes[index] = newSnake;
                    }
                }, 3000);
            } else {
                gameRunning = false;
                document.getElementById('finalScore').textContent = victim.score;
                document.getElementById('deathReason').textContent = reason;
                document.getElementById('gameOverModal').classList.remove('hidden');
                
                // Vibrate on death
                if (navigator.vibrate) {
                    navigator.vibrate([100, 50, 100]);
                }
            }
        }
        
        function drawApples() {
            for (const apple of apples) {
                apple.pulse += 0.1;
                const scale = 1 + Math.sin(apple.pulse) * 0.1;
                const size = (CELL_SIZE - 2) * scale;
                const offset = (CELL_SIZE - size) / 2;
                
                const x = apple.x * CELL_SIZE + offset;
                const y = apple.y * CELL_SIZE + offset;
                
                ctx.shadowColor = '#ef4444';
                ctx.shadowBlur = 8;
                
                ctx.fillStyle = '#ef4444';
                ctx.beginPath();
                ctx.arc(x + size/2, y + size/2, size/2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.beginPath();
                ctx.arc(x + size/3, y + size/3, size/4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
            }
        }
        
        function drawGrid() {
            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.02)';
            ctx.lineWidth = 1;
            
            for (let x = 0; x <= GRID_WIDTH; x++) {
                ctx.beginPath();
                ctx.moveTo(x * CELL_SIZE, 0);
                ctx.lineTo(x * CELL_SIZE, canvas.height);
                ctx.stroke();
            }
            
            for (let y = 0; y <= GRID_HEIGHT; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * CELL_SIZE);
                ctx.lineTo(canvas.width, y * CELL_SIZE);
                ctx.stroke();
            }
        }
        
        function updateScoreboard() {
            const sortedSnakes = [...snakes]
                .filter(s => s.alive)
                .sort((a, b) => b.score - a.score);
            
            const scoreboard = document.getElementById('scoreboard');
            scoreboard.innerHTML = sortedSnakes.slice(0, 5).map((snake, index) => {
                const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : '  ';
                const playerTag = snake.isPlayer ? ' ‚≠ê' : '';
                
                return `
                    <div class="snake-info flex items-center justify-between p-1.5 rounded" 
                         style="background: ${snake.colors.body}33; border-left: 3px solid ${snake.colors.head}">
                        <div class="flex items-center gap-1">
                            <span class="text-xs">${medal}</span>
                            <span class="text-xs font-medium" style="color: ${snake.colors.head}">${snake.colors.name}${playerTag}</span>
                        </div>
                        <div class="text-right">
                            <span class="font-bold text-xs">${snake.score}</span>
                            <span class="text-xs text-gray-400 ml-1">(${snake.length})</span>
                        </div>
                    </div>
                `;
            }).join('');
            
            document.getElementById('appleCount').textContent = apples.length;
            document.getElementById('snakeCount').textContent = snakes.filter(s => s.alive).length;
            document.getElementById('killCount').textContent = totalKills;
            
            if (playerSnake && playerSnake.alive) {
                document.getElementById('playerScore').textContent = playerSnake.score;
            }
        }
        
        function gameLoop() {
            if (!gameRunning || gamePaused) {
                requestAnimationFrame(gameLoop);
                return;
            }
            
            for (const snake of snakes) {
                snake.botAI();
            }
            
            for (const snake of snakes) {
                snake.move();
            }
            
            checkCollisions();
            
            drawGrid();
            drawApples();
            
            for (const snake of snakes) {
                if (!snake.isPlayer) snake.draw();
            }
            if (playerSnake && playerSnake.alive) playerSnake.draw();
            
            updateScoreboard();
        }
        
        function restartGame() {
            initGame();
        }
        
        function togglePause() {
            gamePaused = !gamePaused;
            document.getElementById('pauseBtn').textContent = gamePaused ? '‚ñ∂Ô∏è' : '‚è∏Ô∏è';
        }
        
        function toggleStats() {
            document.getElementById('statsPanel').classList.toggle('open');
        }
        
        function handleControl(direction, event) {
            if (event) {
                event.preventDefault();
            }
            
            if (!playerSnake || !playerSnake.alive || gamePaused) return;
            
            playerSnake.setDirection(DIRECTIONS[direction]);
            
            // Haptic feedback
            if (navigator.vibrate) {
                navigator.vibrate(10);
            }
        }
        
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (!playerSnake || !playerSnake.alive) return;
            
            switch(e.key) {
                case 'ArrowUp': case 'w': case 'W':
                    handleControl('UP', e);
                    break;
                case 'ArrowDown': case 's': case 'S':
                    handleControl('DOWN', e);
                    break;
                case 'ArrowLeft': case 'a': case 'A':
                    handleControl('LEFT', e);
                    break;
                case 'ArrowRight': case 'd': case 'D':
                    handleControl('RIGHT', e);
                    break;
                case ' ':
                    togglePause();
                    e.preventDefault();
                    break;
            }
        });
        
        // Swipe controls
        let touchStartX = 0;
        let touchStartY = 0;
        let touchStartTime = 0;
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchStartTime = Date.now();
        }, { passive: false });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            
            if (!playerSnake || !playerSnake.alive) return;
            
            const touch = e.changedTouches[0];
            const deltaX = touch.clientX - touchStartX;
            const deltaY = touch.clientY - touchStartY;
            const deltaTime = Date.now() - touchStartTime;
            
            // Only register as swipe if it's quick and long enough
            if (deltaTime > 300 || (Math.abs(deltaX) < 30 && Math.abs(deltaY) < 30)) {
                return;
            }
            
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                handleControl(deltaX > 0 ? 'RIGHT' : 'LEFT');
            } else {
                handleControl(deltaY > 0 ? 'DOWN' : 'UP');
            }
        }, { passive: false });
        
        // Prevent default touch behaviors
        document.body.addEventListener('touchmove', (e) => {
            if (e.target === canvas) {
                e.preventDefault();
            }
        }, { passive: false });
        
        // Handle resize
        window.addEventListener('resize', () => {
            const sizes = resizeCanvas();
            // Only reinit if significant change
            if (Math.abs(sizes.gridWidth - GRID_WIDTH) > 5 || Math.abs(sizes.gridHeight - GRID_HEIGHT) > 5) {
                CELL_SIZE = sizes.cellSize;
                GRID_WIDTH = sizes.gridWidth;
                GRID_HEIGHT = sizes.gridHeight;
                // Reinitialize game on significant resize
                initGame();
            }
        });
        
        // Handle orientation change
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                initGame();
            }, 100);
        });
        
        // Initialize and start
        initGame();
        setInterval(gameLoop, 100);
    </script>
</body>
</html>
